# Dice Algebra Calculator - Written in C++

A dice algebra expression lexer, parser, & executor written in C++. 

The purpose of writing this application is to have fun trying out C++ by writing a simple application.
A dice algebra calculator (including lexing, parsing, and execution of string expressions) was selected as something that is probably complex enough to be interesting yet is simple enough to do in an afternoon.

It's also something that can be extended later if that seems like it would be fun (e.g. this application could run a GUI window in which expressions can be input & a breakdown of the results can be shown, etc.).

And finally this is a project which can be done in any language, which allows comparing and constrasting (also fun).

The goal here is to write a program with source code which is as clean as possible (not an easy task without an old hand to ask questions to) and learn about tooling around the language. 

## What is "Dice Algebra?"

Dice algebra consists of simple mathematical expressions where operands may be a "dice roll."

A simple dice roll takes the format `xdy` (or `xDy`) where both `x` and `y` must be integers. 
`xdy` means that a `y`-sided die will be rolled `x` times. For example, `3d6` will roll a 6-sided die three times and sum the results.

The leading `x` may be omitted if it is 1. For example, `d4` rolls a 4-sided die one time.


When rolling more than one die it is possible to keep only the lowest `n` rolls or the highest `n` rolls by appending `ln` or `hn`, respectively, to the roll. For example, `2d20h1` will roll two 20-sided dice and keep the highest result.

In addition to rolling dice, it is possible to include integers, addition `+`, subtraction `-`, multiplcation `*`, integer division `/`, and parenthetical expressions `(...)`. For example, `(2d6 + 5) * 10` will roll two 6-sided die, add five to that result, then mutiply that result by ten. 

All integers must be positive (or 0).

## ANTLR Grammar

The above dice algebra format can be expressed as the following ANTLR 4 grammar. This grammar is more-or-less what this application targets when parsing input.

```ANTLR
grammar DiceAlgebra;

// Parser

add : mult (('+' | '-') mult)* ;
mult : atom (('*' | '/') atom)* ;
atom : (roll | '(' add ')') ;
roll : (integer | longroll | shortroll) ;
longroll : integer D integer ((H integer | L integer))? ;
shortroll : D integer ; 
integer : NUMBER ;

// Lexer

WHITESPACE : ' ' -> skip ;
NUMBER : [0-9]+ ;
D : 'd' | 'D' ;
PLUS : '+' ;
MINUS : '-' ;
MULT: '*' ;
DIV : '/' ;
OPENPAREN : '(' ;
CLOSEPAREN : ')' ;
H : 'h' | 'H' ;
L: 'l' | 'L' ;
```

## How to Run

The dice algebra calculator compiles to a CLI application binary.
When the CLI is executed, it prompts the user for a dice algebra expression. 
Then it computes the expression and prints the result.

An example invocation looks like:

```
> ./dice_algebra_calculator
Please enter a dice algebra expression: 2d6 + 10

Your result is: 14
```

The binary may be invoked with the `--v` flag for verbose output (which prints all dice rolls):

```
> ./dice_algebra_calculator --v
Please enter a dice algebra expression: 2d6 + 10

Rolling 2d6...
You rolled: 3
You rolled: 1

Your result is: 14
```

## How to Build Locally

This project uses [CMake](https://cmake.org/) with [CMake presets](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html).

Please note that all presets are configured for use on Linux.

For local development & debugging, there are CMake presets for both [GCC](https://gcc.gnu.org/) (`debug-gcc`) and [Clang](https://clang.llvm.org/) (`debug-clang`).

Both of these compile with verbose warnings and run the [Clang Tidy](https://clang.llvm.org/extra/clang-tidy/) linter on the source code. Note that you will need to have `clang-tidy` installed for this to work.

These presets may be generated by running the following commands at the root of this repository.

```bash
cmake --preset debug-gcc
cmake --preset debug-clang
```

These two commands create the directories `out/build/debug-gcc` and `out/build/debug-clang`, respectively, containing the generated build systems.

## How to Run the Unit Tests Locally

The unit tests can be run from the CMake build system output directory by compiling them and then running `ctest`.
For example, using a `make` build system...

```
make unit_tests
ctest --output-on-failure
```

## Retrospective Thoughts

Given how people sometimes talk about C++, I was a bit surprised at how easy writing this program actually was. 
Writing it in C++ did not feel significantly more difficult than writing it in Java or Go would have been.

Having just written this same program in C, I was struck by how easy it is to handle memory management with smart pointers.
When writing the C version of this program I was constantly getting memory errors/warnings from the compiler, `clang-tidy`, `valgrind`, etc. due to mistakes in my code.
In contrast, I don't think I encountered a single memory related error when writing the C++ version.
I'm sure in a bigger program or a concurrent program this would be more of a problem, but the standard library types provided by C++ really do seem quite excellent.

It's also worth noting that writing the C version of this program took me over 20 hours - whereas C++ took me 4-5 hours in total excluding unit tests (I haven't used either language since university 10+ years ago).
I would credit most of this to the C++ standard library & presence of OOP features.
One thing I will say in C's favor is that it does compile quite a bit faster. 
The C program ended up being 1456 lines and this one is 716.

The only negative I saw is that, unlike Java, C++ doesn't print a stack trace with errors/exceptions. 
For an app of this size, this was not a problem (I could just jump into the debugger to find the source). 
But for a production system such as a web API, if I began to see "Segmentation fault" logs appear I'd also want to see the line of code they're coming from.
This reminds me a bit of hunting down the source of an error in a poorly written Go application. 
I'm guessing there must be a good solution to this problem though, since I can't be the only one who has this complaint.

In conclusion, C++ was much more pleasant to write than I expected (especially after C) and I'd definitely consider C++ usable for a work project. 
However, I'm not sure if I would do so on a team with mainly beginner-level engineers since the language does give you the option to shoot yourself in the foot with memory management even if the smart pointers make it harder to do that. 

